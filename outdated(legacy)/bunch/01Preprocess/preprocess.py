# -*- coding: utf-8 -*-
"""Preprocess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17KOmDKkp9N7w6amV9NQxhW0KfMpkDM9Q
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install datasets

import os
import cv2
import librosa
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix
from sklearn.model_selection import train_test_split, GridSearchCV, RandomizedSearchCV
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from torchvision.utils import save_image
from datasets import load_dataset
from torch.utils.data import DataLoader, TensorDataset
from tensorflow.keras.callbacks import TensorBoard
import datetime

# Define paths
real_dataset_path = '/content/drive/MyDrive/dataset/TeamDeepwave/dataset/KaggleDataset/real'
fake_dataset_path = '/content/drive/MyDrive/dataset/TeamDeepwave/dataset/KaggleDataset/fake'

# Function to convert audio to spectrogram
def audio_to_spectrogram(file_path):
    y, sr = librosa.load(file_path, sr=None)
    S = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=128)
    S_dB = librosa.power_to_db(S, ref=np.max)
    return S_dB

# Function to create spectrograms from audio files
def prepare_spectrograms(source_dir, output_dir):
    os.makedirs(output_dir, exist_ok=True)
    for file_name in os.listdir(source_dir):
        if file_name.endswith('.wav'):
            file_path = os.path.join(source_dir, file_name)
            spectrogram = audio_to_spectrogram(file_path)
            output_file_path = os.path.join(output_dir, file_name.replace('.wav', '.png'))
            plt.imsave(output_file_path, spectrogram, cmap='viridis')

# Create spectrograms for real and fake datasets
prepare_spectrograms(real_dataset_path, 'real_spectrograms')
prepare_spectrograms(fake_dataset_path, 'fake_spectrograms')

# Load and preprocess data
def load_spectrograms(spectrogram_dir):
    spectrograms = []
    labels = []
    for file_name in os.listdir(spectrogram_dir):
        if file_name.endswith('.png'):
            file_path = os.path.join(spectrogram_dir, file_name)
            spectrogram = cv2.imread(file_path, cv2.IMREAD_GRAYSCALE)
            spectrogram = cv2.resize(spectrogram, (128, 128))
            spectrograms.append(spectrogram)
            label = 0 if 'real' in spectrogram_dir else 1
            labels.append(label)
    return np.array(spectrograms), np.array(labels)

# Load datasets
real_spectrograms, real_labels = load_spectrograms('real_spectrograms')
fake_spectrograms, fake_labels = load_spectrograms('fake_spectrograms')

# Combine and split datasets
X = np.concatenate((real_spectrograms, fake_spectrograms))
y = np.concatenate((real_labels, fake_labels))
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Reshape for Conv2D
X_train = X_train[..., np.newaxis]
X_test = X_test[..., np.newaxis]

# Define the CNN model
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 1)),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test))

# Evaluate the model
y_pred_prob = model.predict(X_test)
y_pred = (y_pred_prob > 0.5).astype("int32")

# Calculate and print metrics
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix

accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)

print(f"Accuracy: {accuracy:.4f}")
print(f"Precision: {precision:.4f}")
print(f"Recall: {recall:.4f}")
print(f"F1 Score: {f1:.4f}")
print(f"Confusion Matrix:\n {conf_matrix}")

# Visualize confusion matrix
plt.figure(figsize=(10, 7))
sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues", xticklabels=["Real", "Fake"], yticklabels=["Real", "Fake"])
plt.xlabel("Predicted")
plt.ylabel("True")
plt.title("Confusion Matrix")
plt.show()

